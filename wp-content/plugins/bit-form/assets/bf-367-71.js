var Oe=Object.defineProperty,me=Object.defineProperties;var we=Object.getOwnPropertyDescriptors;var ue=Object.getOwnPropertySymbols;var ke=Object.prototype.hasOwnProperty,_e=Object.prototype.propertyIsEnumerable;var ce=(t,n,e)=>n in t?Oe(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,G=(t,n)=>{for(var e in n||(n={}))ke.call(n,e)&&ce(t,e,n[e]);if(ue)for(var e of ue(n))_e.call(n,e)&&ce(t,e,n[e]);return t},oe=(t,n)=>me(t,we(n));var le=(t,n,e)=>new Promise((d,b)=>{var S=E=>{try{v(e.next(E))}catch(C){b(C)}},h=E=>{try{v(e.throw(E))}catch(C){b(C)}},v=E=>E.done?d(E.value):Promise.resolve(E.value).then(S,h);v((e=e.apply(t,n)).next())});import{aW as Fe,cc as ye,cd as Ne,ce as Me,cf as We,r as R,cg as qe,ch as u,ci as pe,cj as xe,ck as fe,cl as de,cm as y,cn as Pe,co as K,cp as Ue,cq as he,cr as He,cs as Re,ct as je,c as ze,cu as Ge}from"./main-677.js";const Ee=Fe.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(n=>{t.status="fulfilled",t.value=n},n=>{t.status="rejected",t.reason=n}),t)}),Y={dedupe:!0},Ke=(t,n,e)=>{const{cache:d,compare:b,suspense:S,fallbackData:h,revalidateOnMount:v,revalidateIfStale:E,refreshInterval:C,refreshWhenHidden:B,refreshWhenOffline:J,keepPreviousData:Se}=e,[N,ve,A,De]=Me.get(d),[s,Q]=We(t),p=R.useRef(!1),k=R.useRef(!1),M=R.useRef(s),x=R.useRef(n),P=R.useRef(e),c=()=>P.current,U=()=>c().isVisible()&&c().isOnline(),[I,H,Te,Ve]=qe(d,s),_=R.useRef({}).current,be=u(h)?e.fallback[s]:h,X=(a,r)=>{for(const l in _){const i=l;if(i==="data"){if(!b(a[i],r[i])&&(!u(a[i])||!b(q,r[i])))return!1}else if(r[i]!==a[i])return!1}return!0},Z=R.useMemo(()=>{const a=(()=>!s||!n?!1:u(v)?c().isPaused()||S?!1:u(E)?!0:E:v)(),r=f=>{const T=je(f);return delete T._k,a?G({isValidating:!0,isLoading:!0},T):T},l=I(),i=Ve(),D=r(l),w=l===i?D:r(i);let o=D;return[()=>{const f=r(I());return X(f,o)?(o.data=f.data,o.isLoading=f.isLoading,o.isValidating=f.isValidating,o.error=f.error,o):(o=f,f)},()=>w]},[d,s]),L=pe.useSyncExternalStore(R.useCallback(a=>Te(s,(r,l)=>{X(l,r)||a()}),[d,s]),Z[0],Z[1]),$=!p.current,Ce=N[s]&&N[s].length>0,O=L.data,m=u(O)?be:O,W=L.error,ee=R.useRef(m),q=Se?u(O)?ee.current:O:m,te=(()=>Ce&&!u(W)?!1:$&&!u(v)?v:c().isPaused()?!1:S?u(m)?!1:E:u(m)||E)(),se=!!(s&&n&&$&&te),Ae=u(L.isValidating)?se:L.isValidating,Ie=u(L.isLoading)?se:L.isLoading,F=R.useCallback(a=>le(void 0,null,function*(){const r=x.current;if(!s||!r||k.current||c().isPaused())return!1;let l,i,D=!0;const w=a||{},o=!A[s]||!w.dedupe,f=()=>Re?!k.current&&s===M.current&&p.current:s===M.current,T={isValidating:!1,isLoading:!1},ae=()=>{H(T)},re=()=>{const g=A[s];g&&g[1]===i&&delete A[s]},ie={isValidating:!0};u(I().data)&&(ie.isLoading=!0);try{if(o&&(H(ie),e.loadingTimeout&&u(I().data)&&setTimeout(()=>{D&&f()&&c().onLoadingSlow(s,e)},e.loadingTimeout),A[s]=[r(Q),xe()]),[l,i]=A[s],l=yield l,o&&setTimeout(re,e.dedupingInterval),!A[s]||A[s][1]!==i)return o&&f()&&c().onDiscarded(s),!1;T.error=fe;const g=ve[s];if(!u(g)&&(i<=g[0]||i<=g[1]||g[1]===0))return ae(),o&&f()&&c().onDiscarded(s),!1;const V=I().data;T.data=b(V,l)?V:l,o&&f()&&c().onSuccess(l,s,e)}catch(g){re();const V=c(),{shouldRetryOnError:j}=V;V.isPaused()||(T.error=g,o&&f()&&(V.onError(g,s,V),(j===!0||de(j)&&j(g))&&(!c().revalidateOnFocus||!c().revalidateOnReconnect||U())&&V.onErrorRetry(g,s,V,Le=>{const z=N[s];z&&z[0]&&z[0](y.ERROR_REVALIDATE_EVENT,Le)},{retryCount:(w.retryCount||0)+1,dedupe:!0})))}return D=!1,ae(),!0}),[s,d]),ne=R.useCallback((...a)=>Pe(d,M.current,...a),[]);if(K(()=>{x.current=n,P.current=e,u(O)||(ee.current=O)}),K(()=>{if(!s)return;const a=F.bind(fe,Y);let r=0;const i=Ue(s,N,(D,w={})=>{if(D==y.FOCUS_EVENT){const o=Date.now();c().revalidateOnFocus&&o>r&&U()&&(r=o+c().focusThrottleInterval,a())}else if(D==y.RECONNECT_EVENT)c().revalidateOnReconnect&&U()&&a();else{if(D==y.MUTATE_EVENT)return F();if(D==y.ERROR_REVALIDATE_EVENT)return F(w)}});return k.current=!1,M.current=s,p.current=!0,H({_k:Q}),te&&(u(m)||he?a():He(a)),()=>{k.current=!0,i()}},[s]),K(()=>{let a;function r(){const i=de(C)?C(I().data):C;i&&a!==-1&&(a=setTimeout(l,i))}function l(){!I().error&&(B||c().isVisible())&&(J||c().isOnline())?F(Y).then(r):r()}return r(),()=>{a&&(clearTimeout(a),a=-1)}},[C,B,J,s]),R.useDebugValue(q),S&&u(m)&&s){if(!Re&&he)throw new Error("Fallback data is required when using suspense in SSR.");x.current=n,P.current=e,k.current=!1;const a=De[s];if(!u(a)){const r=ne(a);Ee(r)}if(u(W)){const r=F(Y);u(q)||(r.status="fulfilled",r.value=!0),Ee(r)}else throw W}return{mutate:ne,get data(){return _.data=!0,q},get error(){return _.error=!0,W},get isValidating(){return _.isValidating=!0,Ae},get isLoading(){return _.isLoading=!0,Ie}}},Ye=Ne(Ke),Be=t=>(n,e,d)=>(d.revalidateOnFocus=!1,d.revalidateIfStale=!1,d.revalidateOnReconnect=!1,t(n,e,d)),Je=ye(Ye,Be),ge=t=>{var n;return(t==null?void 0:t.success)&&!((n=t==null?void 0:t.data)!=null&&n.errors)&&!Ge(t.data)},Ze=(t,n,e={})=>{const b=("fetchCondition"in e?e.fetchCondition:!0)?t:null,S=Je(b,h=>{const v=ze(n,Array.isArray(h)?h[0]:h);return e.onLoading&&S.isLoading&&e.onLoading(),v},oe(G({},e),{onSuccess:h=>e.onSuccess&&ge(h)&&e.onSuccess(h.data)}));return R.useEffect(()=>{if(!ge(S.data))return;const{data:h}=S.data;e.onMount?e.onMount(h):e.onSuccess&&e.onSuccess(h)},[]),S};export{Ze as u};
